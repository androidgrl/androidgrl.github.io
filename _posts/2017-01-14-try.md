---
layout: post
title: Alternatives to Using the Try method
---

The architect for our team said that using the try method is like introducing cancer into a code base.
One example of how try is used is:

```
class Order
  def grand_total
    sub_total.try(:*, sales_tax)
  end

  def sub_total
    FooBar.baz
  end
end
```

Say we have a method grand_total which multiplies an order instance's subtotal by the local sales_tax.
What if sub_total were nil?  If you multiiply nil by a number you get an error.  To prevent this, some people use try.  If try is called on nil, it will return nil instead of erroring out.  If it is called on an actual object then it will perform the operation as normal.

One reason why this is insidious is because although it seems harmless, it introduces uncertainty in the code.  It is better to know what kind of object you're dealing with.

In this case, we can avoid using try with an if statement.

```
class Order
  def grand_total
    if subtotal
      (sub_total * sales_tax)
    else
      nil
    end
  end

  def sub_total
    FooBar.baz
  end
end
```

If there's a subtotal it will perform the multiplication, if there is not it will return nil.  Since by default nil is what is returned by else, you can take out the else and make the statement one line.

```
class Order
  def grand_total
    (sub_total * sales_tax) if sub_total
  end

  def sub_total
    FooBar.baz
  end
end
```

What if we wanted to return 0 instead of nil if there was no sub_total?  We could go back to the if else statement but sometimes it can be better to use a Null Object pattern.

```
class Order
  def grand_total
    sub_total * sales_tax
  end

  def sub_total
    result = FooBar.baz
    if result
      result
    else
      NullOrder.new.sub_total
    end
  end
end

class NullOrder
  def sub_total
    0
  end
end
```

Going into the sub_total method, if we get a result from FooBar.baz we return it, if it is nil then we return an instance of NullOrder which has a sub_total of 0.

We then no longer have to have branching inside the grand_total method.  It will either be the actual sub_total or the sub_total on the NullOrder which is 0.

This is an example of Duck Typing.  Duck Typing is when we don't care what type of object we're dealing with only that it has certain behavior.  In this case  we just care that Order and NullOrder both have a sub_total method.

In order to prevent an error in case someone tries to call an undefined method on the NullOrder, we can override the method_missing method to return whatever we want.  For example:

```
class NullOrder
  def method_missing(*_args)
    nil
  end

  def sub_total
    0
  end
end
```

If someone were to call NullOrder.new.whatever, the method_missing method gets called which by default will raise an error.  Instead we override it to return nil.  We add a splat argument in case someone calls an undefined method on it that has arguments.  The underscore in  front of "args" denotes that it's something that's not supposed to be used.
