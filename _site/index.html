<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Androidgrl's Blog &middot; About 3D Printing & Tech, by Jamie Kawahara
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body class="theme-base-0e">

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
      <img src="./public/githubphoto.jpeg">Androidgrl</img>
      <p>Hello!  Welcome to androidgrl's blog!  My name is Jamie Kawahara I am a software developer and 3D printing enthusiast.  I hope you find the tutorials helpful.</p>
      <a href="https://twitter.com/androidgrl">Twitter</a></br>
      <a href="https://github.com/androidgrl">Github</a>
  </div>

  <nav class="sidebar-nav">

    

    
    
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2017. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Androidgrl's Blog</a>
            <small>About 3D Printing & Tech, by Jamie Kawahara</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="//2017/02/17/languages/">
        What Makes a Language Fast?  Five Factors That Affect a Programming Language's Speed
      </a>
    </h1>

    <span class="post-date">17 Feb 2017</span>

    <p>Often I have heard that Ruby is a slow language compared to other languages like Go and Elixir.  I have also heard of startups that originally build their apps on Rails but after hitting it big need to switch to a language like Java in order to scale up.  What are the factors that determine whether a language is considered fast?  How do companies choose which language is most appropriate for their application?  This blog will cover these five factors, a brief overview of how a language is run on your computer processor, and some considerations that go into deciding what is an optimal language for a particular end use.</p>

<p><strong>The Five Main Factors</strong>:</p>

<p><strong>Asynchronous</strong></p>

<p>A language that can be asynchronous can be much faster than a synchronous one.  Let’s say that I want to bake a cake and wash the dishes.  If I put the cake in the oven, wait for it to bake, then wash the dishes, that is synchronous.  There is a little time lost waiting for the cake to bake and doing nothing.  This is how Ruby works, it waits for something to be completely done before starting something else.  Now let’s say that I put the cake in the oven, and while it bakes I do the dishes thereby cutting the overall time to do both tasks.  That is asynchronous.</p>

<p>Javascript is a language that is good at asynch.  One example of how Javascript uses asynch is when a number of api calls are made to a backend to get a bundle of information.  Instead of waiting for each call to get it’s response before making the next one, it can make other calls while it is waiting for previous ones.  If all the calls are necessary to perform an action, then a “promise” can be made which means it will wait for all the calls to complete before performing the action.</p>

<p><strong>Multithreaded</strong></p>

<p>Let’s say that I decided to ask my friend to wash the dishes while I baked a cake.  That is multithreading.  I doubled the working power by asking my friend to help.  Likewise multithreaded languages can spin up multiple “threads” to perform multiple tasks at once.</p>

<p>Java and Elixir are capable of multithreading while Ruby and Javascript are not.</p>

<p><strong>Static Typed</strong></p>

<p>A statically typed language is one in which you have to define what data type a variable is.  For example in Java, if you set a variable to be an array, you have to specify that it is an array.  Ruby on the other hand is dynamically typed.  You don’t have to specify that a variable is any particular data structure, and you can even change what it is at any time.  Although a dynamically typed language can be great to build something quickly, it runs slower than a statically typed language.  This is because a statically typed language knows exactly how much memory to allocate to a variable because it knows exactly what kind of data type it is.  A dynamically typed language on the other hand must allocate a greater amount of memory to store a variable because it doesn’t know what it will be.  Less memory usage results in greater speed.</p>

<p><strong>Functional</strong></p>

<p>A functional language is the opposite of an object-oriented language.  Elixir is a functional language, in which everything is based on functions not objects.  Ruby is an object-oriented language because everything in Ruby including simple things like numbers and strings are objects.  Objects take up a lot of memory and therefore an object-oriented language will be slower.</p>

<p><strong>Compiled</strong></p>

<p>All languages at the end of the day need to be translated into byte code for your computer’s processor.  Some languages like Java and Elixir pre-compile themselves into an intermediate form of byte code that is one step closer to processor byte code.  This extra step makes it easier for the language to be translated into processor byte code, resulting in a faster language.  A language such as Ruby or Python are not compiled but are “interpreted”.  Interpreted just means that it does not go though the pre-compiling step, and has to be directly interpreted into processor byte code which requires more work and is therefore slower.  Still faster yet is C which can compile directly into processor byte code skipping the intermediate step.  A language that is directly compiled into processor byte code is called a “natively compiled” language.</p>

<p>Here is a chart summarizing four popular languages and their characteristics:</p>

<p><img src="./public/chart.png" alt="Chart" /></p>

<p>Lastly, how do you choose which language is good for your app?  When choosing a language it is important to consider what the app is being used for.  For example, math computations are run on the computer’s processor.  Therefore apps that do a lot of math computations will run faster with a natively compiled language because it won’t be slowed down by pre-compiling or interpretation.  Apps that have a relatively few numbers of users but need to wait for multiple api calls to perform a function, would benefit from an asynchronous language.  Apps that have millions of users trying to request a webpage all at once will benefit from a multi-threaded language.  An app that is for a startup which doesn’t have a lot of users yet and needs to be built quickly would do well with Ruby.</p>

<p>In summary the five characteristics that can increase the speed of a language are: Asynchronious, Multi-Threaded, Statically-typed, Functional, and Compiled.  When choosing a language it is good to consider what the app is being used for.</p>

<p>A special thanks to Alex Jensen and Adam Zaninovich for their help in explaining these concepts to me.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="//2017/01/28/namespace/">
        The Namespace Resolution Operator, aka the "double colon operator"
      </a>
    </h1>

    <span class="post-date">28 Jan 2017</span>

    <p>At work I saw an interesting version of the namespace resolution operator, aka the double colon operator.  Previously I had only seen it used to gain access inside scoped modules.  Such as gaining access to the ID defined inside module B below:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>module A
  module B
    ID = 3
  end
end

puts A::B::ID
&gt;&gt; 3
</code></pre>
</div>

<p>But this time it was used at the beginning of a scoped chain of modules like inside module B below:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>module C
  ID = 3
end

module A
  module C
  ID = 4
    module B
      ID = ::C::ID
    end
  end
end

puts A::C::B::ID
&gt;&gt; 3
</code></pre>
</div>

<p>This is called the root namespace resolution operator and it specifies that you are looking for a root level module.  A root level module is one that is not scoped inside another module.  So in this case, it is the module C defined on top which has the ID of 3.</p>

<p>Why was this needed?  It was needed so that it wouldn’t find the scoped module A::C’s ID instead.  For example if we removed the root operator like below, it would return 4 instead of 3.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>module C
  ID = 3
end

module A
  module C
  ID = 4
    module B
      ID = C::ID
    end
  end
end

puts A::C::B::ID
&gt;&gt; 4
</code></pre>
</div>

<p>In fact, if we did not have the ID = 4 defined inside the scoped module C, it would error out and never find the root level module C ID, like below.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>module C
  ID = 3
end

module A
  module C
    module B
      ID = C::ID
    end
  end
end

puts A::C::B::ID
&gt;&gt; error
</code></pre>
</div>

<p>Why does the scoped A::C take precedence over the root level C in the above case?
Because when you call C::ID inside of module B, it starts from where it is inside the scope and moves outward through it’s surrounding modules.  It then finds the outer module A::C and looks for an ID there.  Because it found a module C, it stops there and does not continue even though it has no ID defined, and does not continue to look for the root module C.</p>

<p>Also it is important to note that when two modules have the same name but are scoped differently they are completely different modules.  In fact they might as well have different names.  For example below:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>module C
  ID = 1
end

module A
  module C
    ID = 2
  end
end

puts C::ID
&gt;&gt; 1
puts A::C::ID
&gt;&gt; 2
</code></pre>
</div>

<p>This is not to be confused with monkey patching a module, for example the code below first defines a root level module C with a constant of ONE, then it monkey patches the same root level module to add another constant TWO.  You can monkey patch a module or class as many times as you want, Ruby doesn’t care.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>module C
  ONE = 1
end

module C
  TWO = 2
end

puts C::ONE
&gt;&gt; 1
puts C::TWO
&gt;&gt; 2
</code></pre>
</div>

<p>However, if you tried to monkey patch into a module with the same name but on a different scoped level it would not work because they’re two entirely different modules.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>module C
  ONE = 1
end

module A
  module C
    TWO = 2
  end
end

puts C::TWO
&gt;&gt; error
</code></pre>
</div>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="//2017/01/19/modules/">
        The difference between using include and extend when including modules in a Class
      </a>
    </h1>

    <span class="post-date">19 Jan 2017</span>

    <p>We’ve seen the use of include for including methods from a module into a Class.
The following shows three modules included into Class A:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>module B
  def b
    :b
  end
end

module C
  def c
    :c
  end
end

module D
  def d
    :d
  end
end

class A
  include B
  include C
  include D
end
</code></pre>
</div>

<p>Include turns the methods inside the module into <em>instance</em> methods for that class:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>puts A.new.b &gt;&gt; b
puts A.new.c &gt;&gt; c
puts A.new.d &gt;&gt; d
</code></pre>
</div>

<p>However you can also change the methods into <em>class</em> methods by using extend:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>module B
  def b
    :b
  end
end

module C
  def c
    :c
  end
end

module D
  def d
    :d
  end
end

class A
  extend B
  extend C
  extend D
end

puts A.b &gt;&gt; b
puts A.c &gt;&gt; c
puts A.d &gt;&gt; d
</code></pre>
</div>

<p>Notice how we didn’t have to change the method definitions inside the module to self.method.
This is because modules have no sense of Class, they’re just buckets for methods.  They are called
‘mixins’ because they mix methods into wherever they are included or extended into.</p>

<p>Our team architect Adam Zaninovich gives the analogy of modules being ‘viruses’ and classes being ‘hosts’.  Modules ‘infect’
classes with their ‘methods’ (in a good way in this case), in the sense that viruses inject their dna into host cells.</p>

<p>I wrote include in class A three times which is repetitive.  If you find that you are
including modules in a class many times you can avoid this by using the self.included module method.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>module B
  def self.included(klass)
    klass.include C
    klass.include D
  end

  def b
    :b
  end
end

module C
  def c
    :c
  end
end

module D
  def d
    :d
  end
end

class A
  include B
end

puts A.new.b &gt;&gt; b
puts A.new.c &gt;&gt; c
puts A.new.d &gt;&gt; d
</code></pre>
</div>

<p>Now there is only ‘include B’ inside class A.  Whenever B is included in a Class, it calls self.included
which passes in the class A as an argument.  “self.included” then included modules C and D into the klass
passed as the argument which in our case is class A.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="//2017/01/14/try/">
        Alternatives to Using the Try method
      </a>
    </h1>

    <span class="post-date">14 Jan 2017</span>

    <p>At my work we have a North America team and a China team.  Part of our workflow is to review each others merge requests before merging.  As a junior developer I often see things that I have never seen before and must make an educated decision about whether the unfamiliar pattern is a genuine coding error or deviation from best practices, or just something new I don’t know about.  And because the person who wrote the code is in China in an opposite time zone, it’s not easy to ask them directly about it.  So, while reviewing an MR I saw a use of the try method that I had never seen before.  Here is a simplified version:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class Order
  def grand_total
    sub_total.try(:*, sales_tax)
  end

  def sub_total
    FooBar.baz
  end
end
</code></pre>
</div>

<p>Here the asterisk is the multiplication operator.  Try is trying to multiply sub_total by sales_tax.  If sub_total is nil, it will return nil, instead of erroring out as would happen when trying to multiply nil by a number.</p>

<p>This seemed harmless enough but when I showed it to the team architect in North America he said that using try is like introducing cancer into the code base.  I believe his exact words were “OMG make it stop that try needs to die with fire”.  It seems harmless but then other people see it and start to use it and if allowed to continue can introduce a lot of uncertainty into the code.  It is better to know what kind of result your methods are returning.  We then had a pairing session to use alternative ways to handle nil cases without using try, and here are two of the alternatives we used:</p>

<p>The first alternative is to use an if statement.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class Order
  def grand_total
    if subtotal
      (sub_total * sales_tax)
    else
      nil
    end
  end

  def sub_total
    FooBar.baz
  end
end
</code></pre>
</div>

<p>If there’s a subtotal it will perform the multiplication, if there is not it will return nil.  Since by default nil is what is returned by else, you can take out the else and make the statement one line.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class Order
  def grand_total
    (sub_total * sales_tax) if sub_total
  end

  def sub_total
    FooBar.baz
  end
end
</code></pre>
</div>

<p>What if we wanted to return 0 instead of nil if there was no sub_total?  We could go back to the if else statement but sometimes it can be better to use a Null Object pattern, which is the second alternative.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class Order
  def grand_total
    sub_total * sales_tax
  end

  def sub_total
    result = FooBar.baz
    if result
      result
    else
      NullOrder.new.sub_total
    end
  end
end

class NullOrder
  def sub_total
    0
  end
end
</code></pre>
</div>

<p>Going into the sub_total method, if we get a result from FooBar.baz we return it, if it is nil then we return an instance of NullOrder which has a sub_total of 0.</p>

<p>We then no longer have to have branching inside the grand_total method.  It will either be the actual sub_total or the sub_total on the NullOrder which is 0.</p>

<p>This is an example of Duck Typing.  Duck Typing is when we don’t care what type of object we’re dealing with only that it has certain behavior.  In this case  we just care that Order and NullOrder both have a sub_total method.</p>

<p>In order to prevent an error in case someone tries to call an undefined method on the NullOrder, we can override the method_missing method to return whatever we want.  For example:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class NullOrder
  def method_missing(*_args)
    nil
  end

  def sub_total
    0
  end
end
</code></pre>
</div>

<p>If someone were to call NullOrder.new.whatever, the method_missing method gets called which by default will raise an error.  Instead we override it to return nil.  We add a splat argument in case someone calls an undefined method on it that has arguments.  The underscore in  front of “args” denotes that it’s something that’s not supposed to be used.</p>

<p>In summary, the try method introduces uncertainty into the code because it makes it ok to not know what is being returned by a method.  Alternatives to using try are using if statements and the Null Object pattern.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="//2017/01/04/demeter/">
        Law of Demeter
      </a>
    </h1>

    <span class="post-date">04 Jan 2017</span>

    <p>A few times I’ve been told during code review that something violates the Law of Demeter.  This method for example.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class User
  def user_info
    "#{user.name}, #{user.department.name}"
  end
end
</code></pre>
</div>

<p>Which led me to ask: what is the Law of Demeter, why should I follow it, how do I know if I’m violating it, and how do I avoid violating it?</p>

<p>The Law of Demeter is formally defined as,</p>

<div class="highlighter-rouge"><pre class="highlight"><code>A method of an object may only call methods of:
  The object itself.
  An argument of the method.
  Any object created within the method.
  Any direct properties/fields of the object.
</code></pre>
</div>

<p>The above code sample violates the law with “user.department.name” because it’s calling name on the user’s department, and department is an entirely different object from a user.</p>

<p>In general it is better if one class does not have to know about methods from another class, in other words when the classes are “decoupled”.  This is because it makes the code more flexible.  For example in our code sample, there is only one department for a user.  But what happens if things changed so that a user could have many departments and we wanted the only use the first one for our user_info method?  We would then have to say:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class User
  def user_info
    "#{user.name}, #{user.departments.first.name}"
  end
end
</code></pre>
</div>

<p>This seems reasonable for now but what if we used “user.department” in multiple places?  We’d have to make the same change wherever it was used, which would be cumbersome.</p>

<p>So how do you avoid violating the law?</p>

<p>You could make a custom method in the User class called “department_name”:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class User
  def user_info
    "#{user.name}, #{user.department_name}"
  end

  def department_name
    departments.first.name
  end
end
</code></pre>
</div>

<p>Now the department_name is an immediate property of the user itself, satisfying the law and also making it easier to make future changes if we want to change what we use for the department’s name.</p>

<p>One sign that is often but not always an indication of Demeter violation is chaining of dots.  For example “user.departments.first.name” had chained dots and indeed was a violation.  However, sometimes dot chaining does not mean Demeter violation for example:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>def slug(string)
  string.strip.downcase.tr_s('^[a-z0-9]', '-')
end
</code></pre>
</div>

<p>The above complies with the Law of Demeter because each method is called on a String object.  And the law doesn’t care about the number of methods called, but the number of <em>types</em> of methods called.</p>

<p>For more information see <a href="http://www.virtuouscode.com/2011/07/05/demeter-its-not-just-a-good-idea-its-the-law/">Demeter: It’s not just a good idea. It’s the law.</a></p>

  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page2">Older</a>
  
  
    <span class="pagination-item newer">Newer</span>
  
</div>


      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
