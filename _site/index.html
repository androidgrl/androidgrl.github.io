<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Androidgrl's Blog &middot; About 3D Printing & Tech, by Jamie Kawahara
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body class="theme-base-0e">

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
      <img src="./public/githubphoto.jpeg">Androidgrl</img>
      <p>Hello!  Welcome to androidgrl's blog!  My name is Jamie Kawahara I am a software developer and 3D printing enthusiast.  I hope you find the tutorials helpful.</p>
      <a href="https://twitter.com/androidgrl">Twitter</a></br>
      <a href="https://github.com/androidgrl">Github</a>
  </div>

  <nav class="sidebar-nav">

    

    
    
      
        
      
    
      
        
      
    
      
        
        
      
    
      
    
      
        
      
    
      
        
      
    
      
        
      
    
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2019. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Androidgrl's Blog</a>
            <small>About 3D Printing & Tech, by Jamie Kawahara</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="//2019/01/04/cosmic/">
        The Effect of Cosmic Rays on Software Errors
      </a>
    </h1>

    <span class="post-date">04 Jan 2019</span>

    <p>In my previous blog post I gave an overview of how RAM memory chips store each individual “bit” of binary code inside individual nano-sized capacitors.  In this post I would like to discuss the phenomenon of cosmic ray “bit flipping” in which a cosmic ray hitting such a nano-capacitor can cause it to flip from “0” to “1” or vice versa, and the effect that this has on software errors.</p>

<p>Cosmic rays are not actually energy waves, but high energy atomic particles that constantly shower Earth’s atmosphere.  Most of these particles originated from supernova star explosions and most of them are atomic nuclei stripped of their electrons.  When these particles hit Earth’s atmosphere they cause showers of secondary particles which can reach the Earth’s surface.  Most of these secondary particles consist of energetic neutrons.  If a secondary particle happens to hit a RAM nano-capacitor it can cause it to switch it’s state from un-charged to charged, or vice versa.  This is called a “bit flip” since the bit’s value changes from “0” to “1”, or vice versa.</p>

<p>It is roughly estimated that an average desktop computer experiences 1 bitflip per week per 1GB of RAM (<a href="https://en.wikipedia.org/wiki/Soft_error">wikipedia</a>).  By extrapolation, if a computer has 16GB of RAM then it could possibly have about 2 bitflips per day.  For most consumer electronics, this is not enough to cause serious problems.  However, for servers responsible for financial transactions or scientific calculations, a single bit flip could result in a very serious failure.  For example, a bit flip could potentially cause a digit in someone’s bank account to change.  Although computers can be protected from cosmic rays by burying them, the most practical way to protect data from cosmic ray induced errors is to use ECC memory chips.  ECC memory or “error correcting code memory” is a special kind of memory chip that has software to detect single-bit errors and correct them.</p>

<p>The amount of cosmic ray exposure greatly increases with altitude.  A computer in Denver may receive four times more than one in New York, a computer in an airplane may receive 300 times more, and a computer in space may receive 1000 times more (<a href="http://www.radioactivity.eu.com/site/pages/Dose_Cosmic.htm">radioactivity.eu</a>).  Most computers used in spacecraft use “radiation hardened” chips.  These are memory chips which are made from relatively less conductive marterials, which increase the amount of energy necessary to switch between states, and therefore make it less likely that a cosmic ray would carry enough energy to cause a bit flip.</p>

<p>In summary, cosmic ray induced software errors is a real phenomenon.  Computers which cannot tolerate any data corruption under any circumstances like those used in financial transactions must use special ECC memory to protect against it.  While computers in spacecraft require the use of radiation hardened chips.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="//2019/01/01/binary/">
        How Does a Computer Physically Store Binary Code?
      </a>
    </h1>

    <span class="post-date">01 Jan 2019</span>

    <p>Most software engineers know that a computer stores data as binary code, and that binary code consists of 0’s and 1’s.  However, the 0’s and 1’s themselves are just abstract symbols that represent real physical states within a computer.  In this blog, I will give an overview of these physical states.</p>

<p>Before proceeding I would like to give a brief overview of the mechanisms by which computers store data.  Computers use two main mechanisms to store data: memory and storage.  Memory is used to temporarily store data that the computer uses while it is actively processing things.  Memory is considered “volatile” in that it disappears when the computer is powered-off.  Memory is what is commonly referred to when people say “RAM”.</p>

<p>Storage on the other hand is what the computer uses to store long term data like photos, music, and documents.  Unlike memory, storage is “non-volatile” and remains after the computer is powered-off.  Therefore things like music and documents do not disappear when you power-off your computer.  Historically a computer’s storage device has been a hard disk drive or “HDD”.  Most computers nowadays however use a solid state drive or “SSD”.</p>

<p>So, we have our three main mechanisms for data storage: “RAM”, “HDD”, and “SSD” and we will now examine how they store binary data.</p>

<p><strong>RAM</strong></p>

<p>A RAM memory chip stores binary data through billions of tiny capacitors.  Each capacitor is like a microscopic bucket that holds electrons.  When a capacitor is charged, it’s bucket is filled with electrons.  When it is not charged, the bucket is empty.  Whether or not a capacitor is full or empty determines whether it represents a “0” or “1”.  A charged state is considered a “1”, and an un-charged state is considered a “0”.  Since each “0” or “1” is considered a “bit” of data, and there are 8 bits in a “byte”, and a typical computer can have 8 gigabytes of memory, then there can be approximately 8X8e+9 or (64 billion) RAM memory cells in a computer!  See photo below showing microscopic RAM capacitors.  For a sense of scale, the width of the photo is approximately 1/300th the width of a human hair.</p>

<p><img src="./public/dramcapacitor.png" alt="dram" /></p>

<p>As an aside, RAM capacitors are like leaky buckets which continuously leak out the electrons they’re holding.  Therefore, when the computer is powered-on there is a constant refilling of the buckets that happens multiple times per second.  When the computer is powered-off the buckets drain-out which is why RAM memory is not retained after powering-off.</p>

<p><strong>HDD</strong></p>

<p>A hard disk drive stores binary data through tiny microscopic magnetic lines drawn on a metal disk.  A hard disk drive is composed of a spinning metal disk called a “platter” which is coated with a magnetic material.  It has a read/write head that has a powerful electromagnet on its tip that is capable of drawing tiny magnetically charged lines on the surface of the platter.  See photo below of a typical hard disk drive.</p>

<p><img src="./public/hardisk.jpg" alt="harddrive" /></p>

<p>If a line is magnetically attractive it is considered a “0”, if it is magnetically repulsive it is considered a “1”.  See photo below for a color rendered image showing the magnetic lines on an HDD platter.  The width of the photo is about 1/10 the width of a human hair.</p>

<p><img src="./public/magnetic.png" alt="magnetic" /></p>

<p>A common misconception is that household magnets placed near an HDD can cause memory loss through disrupting the magnetic line patterns.  This is false since most household magnets are not powerful enough to do this.  However, very powerful magnets called “degaussers” are made and used specifically for erasing hard disks by randomizing or scrambling the line patterns.</p>

<p><strong>SDD</strong></p>

<p>A solid state drive stores binary data through billions of tiny transistors.  Each transistor can either exist in a charged or un-charged state.  A charged state is considered a “0”, and an un-charged state a “1”.  Unlike RAM capacitors, SSD transistors are designed to hold their charge after the computer is powered-off.  Therefore, data is not lost after powering-off.  Below is a cross section of three “memory cell” transistors. The one in the center has a charged state and is considered a “0”, while the one to the right has an un-charged state and is considered a “1”.  The width of the photo is approximately 1/300th the width of a human hair.</p>

<p><img src="./public/ssd.png" alt="ssd" /></p>

<p>In summary, the 0’s and 1’s of binary code are abstract symbols which represent real physical states within a computer.  For RAM it is the electric charge inside tiny capacitors, for HDD’s it is the magnetic charge of tiny lines, for SSD’s it is the electric charge inside tiny transistors.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="//2017/04/14/testing/">
        Determining the Scope of What to Test Inside Methods
      </a>
    </h1>

    <span class="post-date">14 Apr 2017</span>

    <p>Sometimes it can be difficult to determine what you want to test inside a method, especially if that method calls other methods, which in turn call other methods and so on.  For example, take the example class <strong>Cake</strong> below.  It has a method called <strong>make</strong> which calls two methods <strong>mix_ingredients</strong> and <strong>bake</strong>, which in turn call <strong>Foo.mix</strong> and <strong>Foo.bake</strong> respectively.</p>

<p>```
class Cake
  def make
    mix_ingredients
    bake
  end</p>

<p>def mix_ingredients
    Foo.mix
  end</p>

<p>private</p>

<p>def bake
    Foo.bake
  end
end</p>

<p>class Foo
  def self.mix
  end</p>

<p>def self.bake
  end
end
```</p>

<p>If we were to write a test for <strong>make</strong>, certainly we would want to test that <strong>mix_ingredients</strong> and <strong>bake</strong> get called.</p>

<p>```
describe Cake do
  describe ‘#make’ do
    it ‘calls mix_ingredients and bake’ do
      expect_any_instance_of(described_class).to receive(:mix_ingredients)
      expect_any_instance_of(described_class).to receive(:bake)</p>

<pre><code>  described_class.new.make
end   end end ```
</code></pre>

<p>However since <strong>mix_ingredients</strong> calls <strong>Foo.mix</strong> and <strong>bake</strong> calls <strong>Foo.bake</strong> would we also want to test that those get called in our test for <strong>make</strong>?  The answer is it depends on whether these get called inside public or private methods.</p>

<p>Taking a look at <strong>mix_ingredients</strong> we see that it’s a public method.  Since all public methods should be tested, we know that we will have a separate test for it and it will check if <strong>Foo.mix</strong> is called.  Here is our updated test file with the test for <strong>mix_ingredients</strong>.</p>

<pre>
describe Cake do
  describe '#make' do
    it 'calls mix_ingredients and bake' do
      expect_any_instance_of(described_class).to receive(:mix_ingredients)
      expect_any_instance_of(described_class).to receive(:bake)

      described_class.new.make
    end
  end
  <b>
  describe '#mix_ingredients' do
    it 'calls mix on Foo' do
      expect(Foo).to receive(:mix)

      described_class.new.mix_ingredients
    end
  end </b>
end
</pre>

<p>But what about <strong>bake</strong>?  Since we don’t test private methods we won’t have a test for this.  However, we still want to test that it calls <strong>Foo.bake</strong>.  Since <strong>bake</strong> gets called when <strong>make</strong> gets called, we need to add a test for this in our <strong>make</strong> test.</p>

<pre>
describe Cake do
  describe '#make' do
    it 'calls mix_ingredients and bake' do
      expect_any_instance_of(described_class).to receive(:mix_ingredients)
      expect_any_instance_of(described_class).to receive(:bake)

      described_class.new.make
    end
  <b>
    it 'calls bake on Foo' do
      expect(Foo).to receive(:bake)

      described_class.new.make
    end
  end
  </b>

  describe '#mix_ingredients' do
    it 'calls mix on Foo' do
      expect(Foo).to receive(:mix)

      described_class.new.mix_ingredients
    end
  end
end
</pre>

<p>In summary, determining the scope of what to test inside of a method that calls other methods, depends on whether public or private methods get called within it.  If a public method is called, then it will have it’s own test and you only need to test that this public method gets called.  If a private method is called, then it won’t have it’s own test, so you’ll need to test what’s happening inside the private method.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="//2017/02/17/languages/">
        What Makes a Language Fast?  Five Factors That Affect a Programming Language's Speed
      </a>
    </h1>

    <span class="post-date">17 Feb 2017</span>

    <p>Often I have heard that Ruby is a slow language compared to other languages like Go and Elixir.  I have also heard of startups that originally build their apps on Rails but after hitting it big need to switch to a language like Java in order to scale up.  What are the factors that determine whether a language is considered fast?  How do companies choose which language is most appropriate for their application?  This blog will cover these five factors, a brief overview of how a language is run on your computer processor, and some considerations that go into deciding what is an optimal language for a particular end use.</p>

<p><strong>The Five Main Factors</strong>:</p>

<p><strong>Asynchronous</strong></p>

<p>A language that can be asynchronous can be much faster than a synchronous one.  Let’s say that I want to bake a cake and wash the dishes.  If I put the cake in the oven, wait for it to bake, then wash the dishes, that is synchronous.  There is a little time lost waiting for the cake to bake and doing nothing.  This is how Ruby works, it waits for something to be completely done before starting something else.  Now let’s say that I put the cake in the oven, and while it bakes I do the dishes thereby cutting the overall time to do both tasks.  That is asynchronous.</p>

<p>Javascript is a language that is good at asynch.  One example of how Javascript uses asynch is when a number of api calls are made to a backend to get a bundle of information.  Instead of waiting for each call to get it’s response before making the next one, it can make other calls while it is waiting for previous ones.  If all the calls are necessary to perform an action, then a “promise” can be made which means it will wait for all the calls to complete before performing the action.</p>

<p><strong>Multithreaded</strong></p>

<p>Let’s say that I decided to ask my friend to wash the dishes while I baked a cake.  That is multithreading.  I doubled the working power by asking my friend to help.  Likewise multithreaded languages can spin up multiple “threads” to perform multiple tasks at once.</p>

<p>Java and Elixir are capable of multithreading while Ruby and Javascript are not.</p>

<p><strong>Static Typed</strong></p>

<p>A statically typed language is one in which you have to define what data type a variable is.  For example in Java, if you set a variable to be an array, you have to specify that it is an array.  Ruby on the other hand is dynamically typed.  You don’t have to specify that a variable is any particular data structure, and you can even change what it is at any time.  Although a dynamically typed language can be great for building something quickly, it runs slower than a statically typed language.  This is because a statically typed language knows exactly how much memory to allocate to a variable because it knows exactly what kind of data type it is.  A dynamically typed language on the other hand must allocate a greater amount of memory to store a variable because it doesn’t know what it will be.  Less memory usage results in greater speed.</p>

<p><strong>Functional</strong></p>

<p>A functional language is the opposite of an object-oriented language.  Elixir is a functional language, in which everything is based on functions not objects.  Ruby is an object-oriented language because everything in Ruby including simple things like numbers and strings are objects.  Objects take up a lot of memory and therefore an object-oriented language will be slower.</p>

<p><strong>Compiled</strong></p>

<p>All languages at the end of the day need to be translated into byte code for your computer’s processor.  Some languages like Java and Elixir pre-compile themselves into an intermediate form of byte code that is one step closer to processor byte code.  This extra step makes it easier for the language to be translated into processor byte code, resulting in a faster language.  A language such as Ruby or Python are not compiled but are “interpreted”.  Interpreted just means that it does not go though the pre-compiling step, and has to be directly interpreted into processor byte code which requires more work and is therefore slower.  Still faster yet is C which can compile directly into processor byte code skipping the intermediate step.  A language that is directly compiled into processor byte code is called a “natively compiled” language.</p>

<p>Here is a chart summarizing four popular languages and their characteristics:</p>

<p><img src="./public/chart.png" alt="Chart" /></p>

<p>Lastly, how do you choose which language is good for your app?  When choosing a language it is important to consider what the app is being used for.  For example, math computations are run on the computer’s processor.  Therefore apps that do a lot of math computations will run faster with a natively compiled language because it won’t be slowed down by pre-compiling or interpretation.  Apps that have a relatively few numbers of users but need to wait for multiple api calls to perform a function, would benefit from an asynchronous language.  Apps that have millions of users trying to request a webpage all at once will benefit from a multi-threaded language.  An app that is for a startup which doesn’t have a lot of users yet and needs to be built quickly would do well with Ruby.</p>

<p>In summary the five characteristics that can increase the speed of a language are: Asynchronious, Multi-Threaded, Statically-typed, Functional, and Compiled.  When choosing a language it is good to consider what the app is being used for.</p>

<p>A special thanks to Alex Jensen and Adam Zaninovich for their help in explaining these concepts to me.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="//2017/01/28/namespace/">
        The Namespace Resolution Operator, aka the "double colon operator"
      </a>
    </h1>

    <span class="post-date">28 Jan 2017</span>

    <p>At work I saw an interesting version of the namespace resolution operator, aka the double colon operator.  Previously I had only seen it used to gain access inside scoped modules.  Such as gaining access to the ID defined inside module B below:</p>

<p>```
module A
  module B
    ID = 3
  end
end</p>

<p>puts A::B::ID
» 3
```</p>

<p>But this time it was used at the beginning of a scoped chain of modules like inside module B below:</p>

<p>```
module C
  ID = 3
end</p>

<p>module A
  module C
  ID = 4
    module B
      ID = ::C::ID
    end
  end
end</p>

<p>puts A::C::B::ID
» 3
```</p>

<p>This is called the root namespace resolution operator and it specifies that you are looking for a root level module.  A root level module is one that is not scoped inside another module.  So in this case, it is the module C defined on top which has the ID of 3.</p>

<p>Why was this needed?  It was needed so that it wouldn’t find the scoped module A::C’s ID instead.  For example if we removed the root operator like below, it would return 4 instead of 3.</p>

<p>```
module C
  ID = 3
end</p>

<p>module A
  module C
  ID = 4
    module B
      ID = C::ID
    end
  end
end</p>

<p>puts A::C::B::ID
» 4
```</p>

<p>In fact, if we did not have the ID = 4 defined inside the scoped module C, it would error out and never find the root level module C ID, like below.</p>

<p>```
module C
  ID = 3
end</p>

<p>module A
  module C
    module B
      ID = C::ID
    end
  end
end</p>

<p>puts A::C::B::ID
» error
```</p>

<p>Why does the scoped A::C take precedence over the root level C in the above case?
Because when you call C::ID inside of module B, it starts from where it is inside the scope and moves outward through it’s surrounding modules.  It then finds the outer module A::C and looks for an ID there.  Because it found a module C, it stops there and does not continue even though it has no ID defined, and does not continue to look for the root module C.</p>

<p>Also it is important to note that when two modules have the same name but are scoped differently they are completely different modules.  In fact they might as well have different names.  For example below:</p>

<p>```
module C
  ID = 1
end</p>

<p>module A
  module C
    ID = 2
  end
end</p>

<p>puts C::ID
» 1
puts A::C::ID
» 2
```</p>

<p>This is not to be confused with monkey patching a module, for example the code below first defines a root level module C with a constant of ONE, then it monkey patches the same root level module to add another constant TWO.  You can monkey patch a module or class as many times as you want, Ruby doesn’t care.</p>

<p>```
module C
  ONE = 1
end</p>

<p>module C
  TWO = 2
end</p>

<p>puts C::ONE
» 1
puts C::TWO
» 2
```</p>

<p>However, if you tried to monkey patch into a module with the same name but on a different scoped level it would not work because they’re two entirely different modules.</p>

<p>```
module C
  ONE = 1
end</p>

<p>module A
  module C
    TWO = 2
  end
end</p>

<p>puts C::TWO
» error
```</p>

  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page2">Older</a>
  
  
    <span class="pagination-item newer">Newer</span>
  
</div>


      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
  </body>
</html>
